*******************************************************************************
*       I2C Driver for the IMU
*       November 2024
*       This program uses PORTD pins 4 and 5 as SDA and SCL respectively
*       DDRC 0 = INPUT, DDRC 1 = OUTPUT
*******************************************************************************
portd       EQU         $1008          ; port d data address
ddrd        EQU         $1009          ; data direction register d
send_buffer EQU         $2002
rcv_buffer  EQU         $2006
rcv_flag    EQU         $2007          ; if 0 = send, if 1 receive
register    EQU         $2008          ; where we will save the acknack



gyro_write  EQU         %11010000      ; i think? 
gyro_read   EQU         %11010001      ; i think? 
gyro_nack   EQU         %11110000
gyro_whoami EQU         %00000000       ; whoami register 
bmp085      EQU         %11101110      ; bmp085 address

; OR these to turn that bit off
sda         EQU        %00010000            ; 
scl         EQU        %00100000

        ; AND these to turn that bit off
sdam        EQU        $EF              ; inverted bitmask for SDA           
sclm        EQU        $DF              ; inverted bitmask for SCL


        ; testing if my method works at all
i2cstore    EQU        $2000            ; where I want to keep my i2c data

temp_high   EQU         $2010           ; High byte of temperature
temp_low    EQU         $2011           ; Low Byte of the temperature

temp_result EQU         $2200           ; (2 bytes) spot for the temperature result
remainder   EQU         $2302           ; spot for the remainder
tmp         EQU         $2600           ; scratch space for math operations

*******************************************************************************
*       SEND BYTE SUBROUTINE
*******************************************************************************
    ORG    $2400
sb: 
    ldx     #$08                                    ; send 8 bits
    ldab    send_buffer
send_byte_loop:
    ldaa    #scl                                    ; put the clock low = set ddrd high
    oraa    ddrd
    staa    ddrd

    rolb                                            ; look at the msb

    bcs     set_sda                                 ; branch depending on its value
    bcc     clear_sda

set_sda:                                      ; ddrd LOW -> SDA HIGH
    ldaa    #sdam
    anda    ddrd
    staa    ddrd
    bra     next_bit

clear_sda:                                      ; ddrd HIGH -> SDA LOW
    ldaa    #sda
    oraa    ddrd
    staa    ddrd
    bra     next_bit

next_bit:    
    ldaa    #sclm                               ; clock needs to go high now, ddrd is LOW
    anda    ddrd
    staa    ddrd

    dex
    bne     send_byte_loop
    rts

*******************************************************************************
*           READ BYTE SUBROUTINE
*******************************************************************************
rb:
    ldx     #$08

    ldaa    #sdam   ; release the buss
    anda    ddrd
    staa    ddrd
rb_loop:
    ldaa    #scl    ; bring the clock low
    oraa    ddrd
    staa    ddrd

    ldaa    #sclm   ; bring it high again
    anda    ddrd
    staa    ddrd
    
    jsr     read_port   ; i am putting it here, because data changes while the clock is low, but 
    
    dex                 ; it may need to be in the first rb: routine also
    bne     rb_loop     ; this was "send_byte_loop", and wasn't working correclty
    rts


*******************************************************************************
*           START CONDITION 
*******************************************************************************
start_condition:            
    ldaa    #sclm                           ; if the clock line is low, make it high
    anda    ddrd
    staa    ddrd

*   if SDA is LOW, make it high
    ldaa    #sdam
    anda    ddrd
    staa    ddrd

*   then lower it
    ldaa    #sda
    oraa    ddrd
    staa    ddrd
    rts

     
*******************************************************************************
*       MAIN I2C READ LOOP                                                    *
*******************************************************************************
    ORG     $3000                   ; entry point for i2c driver

*   ldaa    #$00                    ; configure portd as an input
*   staa    ddrd                    ; store portd configuratoin
i2cmain:
    ldaa    #$00                    ; initialize i2cstore to zero
    staa    i2cstore                ; ^^
    ldaa    #$00                    ; rcv_flag = 0, means we are transmitting
    staa    rcv_flag                ; rcv_flag = 1, means we are recieving data
    jsr     start_condition         ; send gyro write

    ldaa    #gyro_write             ; send the gyro write command on the bus
    staa    send_buffer             
    jsr     sb                      ; send byte
    jsr     ack_nack                

    ldaa    register                    ; Register Address (RA)
    staa    send_buffer
    jsr     sb    
    jsr     ack_nack                ; ACK

    jsr     start_condition         ; S

    ldaa    #$00                    ; indicate that we sending
    staa    rcv_flag                ; i'm not sure if this is used right now
    jsr     start_condition         ; requires SCL to be left high by the previous routine
    ldaa    #gyro_read              ; ADR + R
    staa    send_buffer
    jsr     sb
    jsr     ack_nack                ; ACK

    jsr     rb                      ; DATA  (for now just want to see data on the bus
    jsr     ack_nack


    jsr     stop_condition
    rts
    
*    swi
*******************************************************************************
*       END I2C MAIN LOOP
*******************************************************************************

*******************************************************************************
*       ENTRY POINT OF PROGRAM
*******************************************************************************
    ORG     $3400
main_init:

    ldaa    #$00            ; iteration counter starts at 0
    staa    $0f             ; place to put the iterations remaining

    ldaa    #$1B            ; TEMP_HIGH register address
    staa    register        ; where we store the register address

    ldx    #temp_result    ; where we want to store the result in the end
    stx    $39fe
    
main_loop:
    jsr     i2cmain         ; call the i2c driver

    ldx     $39fe          ; load the address

    ldaa    i2cstore        ; take the data from the temporary i2cstore
    staa    0, x          ; store the i2c store data in the temp_high locaiton + x

    jsr     $ffbb           ; print the character

    ldaa    #$20
    jsr     $ffb8           ; print a space

    inx                     ; increment x and store it for the next iteration
    stx     $39fe           ; probably we can save a step here but i dont care right now 

    ldaa    register        ; load the register we are reading into A
    inca                    ; increment it and store it for next iteration
    staa    register        

    ldaa    $0f             ; look at the number of iterations
    inca                    ; add 1
    staa    $0f             ; save the current iteration count
    suba    #$08            ; number of iterations to stop after
    bne     main_loop       ; if we aren't at 0 keep going.

    jsr     $ffc4           ; print a carriange return/linefeed

    bra     main_init



    swi
    
    
* dont you just wish there were functions?
* in reality this runs forever, but idk why
* be careful we don't touch B

* read operation for ack/nack
ack_nack:
    ldaa    #scl    ; clock low once more, ddrd HIGH
    oraa    ddrd
    staa    ddrd

* sda has to be an input.  Data is allowed to change only when the clock is low.  
* so once the clock goes low that gives our main and secondaries the chance to do their work
    ldaa    #sdam
    anda    ddrd
    staa    ddrd
    
    nop             ; just give it some time
    nop

* clock high = ddrd low
    ldaa    #sclm
    anda    ddrd
    staa    ddrd

* off by one errors
* clock low once more = ddrd high
    ldaa    #scl
    oraa    ddrd
    staa    ddrd

    rts

* i actually need to read in the nack some how


* while the clock is high, address goes high
* putting SDA high = DDRD LOW

stop_condition:
* clock low once more = ddrd high (bus control transfers back to M)
    ldaa    #scl
    oraa    ddrd
    staa    ddrd

* you have to think in terms of what is allowed to happen on the bus
* set SDA HIGH by setting its ddrd bit LOW
    ldaa    #sda
    oraa    ddrd
    staa    ddrd

    
    ldaa    #sclm               ; clock high = ddrd low
    anda    ddrd
    staa    ddrd

    nop                         ; here for superstitious reasons
    nop
    nop

    ldaa    #sdam               ; set sda to input/high = clear SDA in DDRD
    anda    ddrd
    staa    ddrd
    rts

    
    swi

*;read port is known to work in a small test
read_port:
    ldaa    portd
    ldy     #$05 

    shift_left:                                     ; shift the data into C
        lsra
        dey                                         ; decrement x
        bne     shift_left

    ldaa    i2cstore 
    rola 
    staa    i2cstore 
    rts

*******************************************************************************
*           TEMPERATURE CONVERSION FROM ITG-3200 DATASHEET
*           temp_high and temp_low have to be consequetive bytes
*           There is probably some storage on X that needs to be done in order
*           to use this in a loop.
*******************************************************************************
    ORG     $3500
temp_convert:
    ldd     temp_high                           ; load D with the temperature
    eora    #$ff                                ; it is a twos compliment negative number
    eorb    #$ff                                ; swap the upper and lower bytes (no EORD instr.)
    addd    #$01                                ; increment by one to complete conversion
    ldx     #280                                ; load decimal 280 into the denominator
    idiv                                        ; divide the temperature by 280
    std     remainder                           ; store the remainder
    xgdx                                        ; the quotient gets put into X   this part works     this part works
    std     tmp                                 ; temporarily store d in the temporary scratch space
    ldd     #82                                 ; subtract the linear constant
    subd    tmp                                 ; 82 - tmp
    std     temp_result
    swi

bin2bcd
