*******************************************************************************
*       I2C Driver for the IMU
*       November 2024
*       This program uses PORTD pins 4 and 5 as SDA and SCL respectively
*       DDRC 0 = INPUT, DDRC 1 = OUTPUT
*******************************************************************************
portd       EQU         $1008          ; port d data address
ddrd        EQU         $1009          ; data direction register d
send_buffer EQU         $2002
rcv_buffer  EQU         $2006
rcv_flag    EQU         $2007          ; if 0 = send, if 1 receive
register    EQU         $2008          ; where we will save the acknack



gyro_write  EQU         %11010000      ; itg3200 write addr 
gyro_read   EQU         %11010001      ; itg3200 read addr
gyro_nack   EQU         %11110000      ; test address 
gyro_whoami EQU         %00000000      ; whoami register 
bmp085      EQU         %11101110      ; bmp085 address

; OR these to turn that bit off
sda         EQU        %00010000            ; 
scl         EQU        %00100000

        ; AND these to turn that bit off
sdam        EQU        $EF              ; inverted bitmask for SDA           
sclm        EQU        $DF              ; inverted bitmask for SCL


        ; testing if my method works at all
i2cstore    EQU        $2000            ; where I want to keep my i2c data


* HEX OUTPUT OF SENSOR LOCATION
temp_result EQU         $2200           ; (2 bytes) spot for the temperature result
gyro_x_res  EQU         $2202           ; (2 bytes) spot for the gyro_x result 
gyro_y_res  EQU         $2204           ; (2 bytes) spot for the temperature decimal
gyro_z_res  EQU         $2206           ; (2 bytes) spot for the temperature decimal
remainder   EQU         $2302           ; spot for the remainder
tmp         EQU         $2600           ; scratch space for math operations

conv_res    EQU         $2240           ; spot to store the conversion to human readable
store       EQU         $2990           ; place to store the bin2bcd 
is_twos     EQU         $2292           ; place to store if it is a twos compliment number

*******************************************************************************
*       SEND BYTE SUBROUTINE
*******************************************************************************
    ORG    $2400
sb: 
    ldx     #$08                                    ; send 8 bits
    ldab    send_buffer
send_byte_loop:
    ldaa    #scl                                    ; put the clock low = set ddrd high
    oraa    ddrd
    staa    ddrd

    rolb                                            ; look at the msb

    bcs     set_sda                                 ; branch depending on its value
    bcc     clear_sda

set_sda:                                      ; ddrd LOW -> SDA HIGH
    ldaa    #sdam
    anda    ddrd
    staa    ddrd
    bra     next_bit

clear_sda:                                      ; ddrd HIGH -> SDA LOW
    ldaa    #sda
    oraa    ddrd
    staa    ddrd
    bra     next_bit

next_bit:    
    ldaa    #sclm                               ; clock needs to go high now, ddrd is LOW
    anda    ddrd
    staa    ddrd

    dex
    bne     send_byte_loop
    rts

*******************************************************************************
*           READ BYTE SUBROUTINE
*******************************************************************************
rb:
    ldx     #$08

    ldaa    #sdam   ; release the buss
    anda    ddrd
    staa    ddrd
rb_loop:
    ldaa    #scl    ; bring the clock low
    oraa    ddrd
    staa    ddrd

    ldaa    #sclm   ; bring it high again
    anda    ddrd
    staa    ddrd
    
    jsr     read_port   ; i am putting it here, because data changes while the clock is low, but 
    
    dex                 ; it may need to be in the first rb: routine also
    bne     rb_loop     ; this was "send_byte_loop", and wasn't working correclty
    rts


*******************************************************************************
*           START CONDITION 
*******************************************************************************
start_condition:            
    ldaa    #sclm                           ; if the clock line is low, make it high
    anda    ddrd
    staa    ddrd

*   if SDA is LOW, make it high
    ldaa    #sdam
    anda    ddrd
    staa    ddrd

*   then lower it
    ldaa    #sda
    oraa    ddrd
    staa    ddrd
    rts

     
*******************************************************************************
*       MAIN I2C READ LOOP                                                    *
*******************************************************************************
    ORG     $3000                   ; entry point for i2c driver

*   ldaa    #$00                    ; configure portd as an input
*   staa    ddrd                    ; store portd configuratoin
i2cmain:
    ldaa    #$00                    ; initialize i2cstore to zero
    staa    i2cstore                ; ^^
    ldaa    #$00                    ; rcv_flag = 0, means we are transmitting
    staa    rcv_flag                ; rcv_flag = 1, means we are recieving data
    jsr     start_condition         ; send gyro write

    ldaa    #gyro_write             ; send the gyro write command on the bus
    staa    send_buffer             
    jsr     sb                      ; send byte
    jsr     ack_nack                

    ldaa    register                ; Register Address (RA)
    staa    send_buffer
    jsr     sb    
    jsr     ack_nack                ; ACK

    jsr     start_condition         ; S

    ldaa    #gyro_read              ; ADR + R
    staa    send_buffer
    jsr     sb
    jsr     ack_nack                ; ACK

    jsr     rb                      ; DATA  (for now just want to see data on the bus
    jsr     ack_nack


    jsr     stop_condition
    rts
    
*    swi
*******************************************************************************
*       END I2C MAIN LOOP
*******************************************************************************

*******************************************************************************
*       ENTRY POINT OF PROGRAM (DRIVER LOOP)
*******************************************************************************
    ORG     $3400
main_init:

    ldaa    #$00            ; iteration counter starts at 0
    staa    $0f             ; place to put the iterations remaining

    ldaa    #$1B            ; TEMP_HIGH register address
    staa    register        ; where we store the register address

    ldx    #temp_result    ; where we want to store the result in the end
    stx    $39fe
    
main_loop:
    jsr     i2cmain         ; call the i2c driver

    ldx     $39fe           ; load the address

    ldaa    i2cstore        ; take the data from the temporary i2cstore
    staa    0, x            ; store the i2c store data in the temp_result locaiton + x

    jsr     $ffbb           ; print the character

    ldaa    #$20
    jsr     $ffb8           ; print a space

    inx                     ; increment x and store it for the next iteration
    stx     $39fe           ; probably we can save a step here but i dont care right now 

    ldaa    register        ; load the register we are reading into A
    inca                    ; increment it and store it for next iteration
    staa    register        

    ldaa    $0f             ; look at the number of iterations
    inca                    ; add 1
    staa    $0f             ; save the current iteration count
    suba    #$08            ; number of iterations to stop after
    bne     main_loop       ; if we aren't at 0 keep going.

    jsr     $ffc4           ; print a carriange return/linefeed


*******************************************************************************
*       Area where we print the conversions to the display
*******************************************************************************

*******************************************************************************
*       PRINT TEMPERATURE CONVERSION
*******************************************************************************
    jsr     temp_convert
    jsr     bin2bcd

    ldaa    $2991           ; output first temperature digit 
    jsr     $ffb5           ; right nibble and out

    ldaa    $2992           ; output second numerator digit
    jsr     $ffb5

    ldaa    #$2e            ; output decimal point
    jsr     $ffb8

    ldaa    $2993
    jsr     $ffb5
    ldaa    $2994
    jsr     $ffb5

*******************************************************************************

    jsr     $ffc4           ; print a carriange return/linefeed


    bra     main_init



    swi
    
    
* dont you just wish there were functions?
* in reality this runs forever, but idk why
* be careful we don't touch B

* read operation for ack/nack
ack_nack:
    ldaa    #scl    ; clock low once more, ddrd HIGH
    oraa    ddrd
    staa    ddrd

* sda has to be an input.  Data is allowed to change only when the clock is low.  
* so once the clock goes low that gives our main and secondaries the chance to do their work
    ldaa    #sdam
    anda    ddrd
    staa    ddrd
    
    nop             ; just give it some time
    nop

* clock high = ddrd low
    ldaa    #sclm
    anda    ddrd
    staa    ddrd

* off by one errors
* clock low once more = ddrd high
    ldaa    #scl
    oraa    ddrd
    staa    ddrd

    rts

* i actually need to read in the nack some how


* while the clock is high, address goes high
* putting SDA high = DDRD LOW

stop_condition:
* clock low once more = ddrd high (bus control transfers back to M)
    ldaa    #scl
    oraa    ddrd
    staa    ddrd

* you have to think in terms of what is allowed to happen on the bus
* set SDA HIGH by setting its ddrd bit LOW
    ldaa    #sda
    oraa    ddrd
    staa    ddrd

    
    ldaa    #sclm               ; clock high = ddrd low
    anda    ddrd
    staa    ddrd

    nop                         ; here for superstitious reasons
    nop
    nop

    ldaa    #sdam               ; set sda to input/high = clear SDA in DDRD
    anda    ddrd
    staa    ddrd
    rts

    
    swi

*;read port is known to work in a small test
read_port:
    ldaa    portd
    ldy     #$05 

    shift_left:                                     ; shift the data into C
        lsra
        dey                                         ; decrement x
        bne     shift_left

    ldaa    i2cstore 
    rola 
    staa    i2cstore 
    rts

*******************************************************************************
*           GYRO CONVERSION FROM ITG-3200 DATASHEET
*           Converts raw 2s compliment hex to a form which can be bin2bcd'ed for
*           printing to the screen
*           There is a lot of repeat code here, because I'm focused on finishing the project
*           Let's see if I grow to regret that in the future.
********************************************************************************
    ORG     $3500
gyro_x_convert:
    ldaa    temp_result+4                       ; load D with the gyro_x_result
    ldab    temp_result+6                        ; not sure why this is offset it happening

    rola                                        ; check if the number is negative
    bcs     gx_is_neg                           ; check the msb for a 1
    bcc     gx_is_pos                           ; branch to positive if the msb is a 0, negative if a 1

gx_is_neg:
    rora
    eora    #$ff
    eorb    #$ff
    addd    #1

    ldx     #14                                 ; load decimal 14 into the denominator
    idiv                                        ; divide the gyro x by 14
    std     remainder                           ; store the remainder
    xgdx                                        ; the quotient gets put into X   this part works     this part works

    subd    #1                                  ; convert back to twos compliment for addition part
    eora    #$ff                                ; i'm just going backwards on the steps i did earlier
    eorb    #$ff                                ; A and B registers together form the D register
    std     tmp                                 ; temporarily store d in the temporary scratch space
    ldd     #20                                 ; subtract the linear constant
    addd    tmp                                 ; 20 + tmp
    std     conv_res                            ; store at $2240  

    bra     decimal

gx_is_pos:
    rola

    ldx     #14                                 ; load decimal 14 into the denominator
    idiv                                        ; divide the gyro x by 14
    std     remainder                           ; store the remainder
    xgdx                                        ; the quotient gets put into X   this part works     this part works

    std     tmp                                 ; temporarily store d in the temporary scratch space
    ldd     #20                                 ; subtract the linear constant
    addd    tmp                                 ; 20 + tmp
    std     conv_res                            ; store at $2240  
    bra     decimal

   
*   swi                                         ; sometimes SWI'ing here is nice for debugging
decimal:
    ldd     remainder                           ; load the remainder from before
    ldx     #20                                ; load decimal 20 into the denominator
    fdiv                                        ; floating point divide
    xgdx                                        ; the quotient gets put into X 
    std     tmp+2                               ; temporary spot for the "decimalized" remainder
    ldd     #14
    subd    tmp+2
    std     conv_res+2                          ; store the decimal part 

    ldd     conv_res
    std     $2260
    swi

*******************************************************************************
*           TEMPERATURE CONVERSION FROM ITG-3200 DATASHEET
*           Converts raw 2s compliment hexadecimal to a form which can be
*           Bin2BCD'ed for printing to the screen. 
*           temp_high and temp_low have to be consequetive bytes
*           There is probably some storage on X that needs to be done in order
*           to use this in a loop.
*           Converts the temperature stores in temp_result to a value that can be 
*           BIN2BCD'ed at $2260
*           TODO: Implement the positive decimal case
*******************************************************************************
*   ORG     $3500                               ; commenting out for now to impelment gyro code
temp_convert:
    ldaa    temp_result                         ; load D with the temperature (usually $2010)
    ldab    temp_result+2                       ; dont you hate when you wake up and your code is arranging the data every other byte now, and you cant figure out why
    eora    #$ff                                ; it is a twos compliment negative number
    eorb    #$ff                                ; swap the upper and lower bytes (no EORD instr.)
    addd    #$01                                ; increment by one to complete conversion
    ldx     #280                                ; load decimal 280 into the denominator
    idiv                                        ; divide the temperature by 280
    std     remainder                           ; store the remainder
    xgdx                                        ; the quotient gets put into X   this part works     this part works
    std     tmp                                 ; temporarily store d in the temporary scratch space
    ldd     #82                                 ; subtract the linear constant
    subd    tmp                                 ; 82 - tmp
    std     conv_res                            ; store at $2240  
   
*   swi                                         ; sometimes SWI'ing here is nice for debugging
    ldd     remainder                           ; load the remainder from before
    ldx     #280                                ; load decimal 280 into the denominator
    fdiv                                        ; floating point divide
    xgdx                                        ; the quotient gets put into X 
    std     tmp+2                               ; temporary spot for the "decimalized" remainder
    ldd     #14
    subd    tmp+2
    std     conv_res+2                          ; store the decimal part 

    rola
    bcs     if_neg
    bcc     if_pos
    
    


* there is no way this works on the first try
* if the small part is negative... subtract it...
* if the small part is positive... add it..
* how hard could it be?!?!?!?
* this probably only works on the version we have in memory at this moment (subtraction case)
* there are also probably a bunch of different edge cases
* for sure this one only works if the thing is negative, if it works at all

if_neg:
    rora                                        ; we checked the MSB, now get it back from the carry flag
    ldab    conv_res+2                          ; we can only fit the top byte of the decimal, without having a dedicated place in memory
    ldaa    #0                                  ; even so, since we are using D, we have to form the byte correctly
    eora    #$ff                                ; flip every bit
    adda    #1                                  ; add 1 to convert the decimal part to its positive magnitude
    ldx     #10                                 ; get ready to divide by 10
    idiv                                        ; divide by 10 to get the place value correct
    xgdx                                        ; QUOTIENT IS IN X, so put it in D
    std     tmp                                 ; we're kinda committing to using D here

    ldaa    conv_res+1                          ; only A should be full after the division operation for the expected range of temperatures 
    ldab    #100                                ; multiply this by 100
    mul                                         ; execute multiplication
    subd    tmp                                 ; subtract the quotient from earlier
    std     $2260                               ; :prayge:
    bra     math_done

if_pos:
    rora                                        ; we checked the MSB, now get it back from the carry flag
    ldab    conv_res+2                          ; we can only fit the top byte of the decimal, without having a dedicated place in memory
    ldaa    #0                                  ; even so, since we are using D, we have to form the byte correctly
    eora    #$ff                                ; flip every bit
    adda    #1                                  ; add 1 to convert the decimal part to its positive magnitude
    ldx     #10                                 ; get ready to divide by 10
    idiv                                        ; divide by 10 to get the place value correct
    xgdx                                        ; QUOTIENT IS IN X, so put it in D
    std     tmp                                 ; we're kinda committing to using D here

    ldaa    conv_res+1                          ; only A should be full after the division operation for the expected range of temperatures 
    ldab    #100                                ; multiply this by 100
    mul                                         ; execute multiplication
    addd    tmp                                 ; add the quotient from earlier (we are in the positive case)
    std     $2260                               ; :prayge:
    bra     math_done


math_done:
    rts
*******************************************************************************
*       BIN2BCD
*******************************************************************************
    ORG     $3700
bin2bcd:
    ldd     $2260
    ldx     #10000
    idiv    
    xgdx
    stab    store
    xgdx

    ldx     #1000
    idiv
    xgdx
    stab    store+1
    xgdx

    ldx     #100
    idiv
    xgdx
    stab    store+2
    xgdx

    ldx     #10
    idiv
    xgdx
    stab    store+3
    xgdx

    stab    store+4
    rts
